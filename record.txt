기존 답
1 1 1 1 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 2 0 0 8
(11, 12)
1.0
1 1 1 1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1 
(1, 13)
8.0


바뀐 follower 계산방식
1 1 1 1 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 0 0 0 0 0 0 0 0 0 7 2 0 7 8
(11, 12)
1.0
1 1 1 1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
(1, 13)
8.0

다른 부분

edge :  (8, 13)  edge weight:  8.0
6

edge :  (10, 13)  edge weight:  8.0
7


<기록>
1. 예제에서 11번과 12번 노드를 이을 때 11번과 12번의 노드가 같은 coreness 값을 갖기 때문에 
sigma plus 값을 구할 때 coreness 가 큰 neighbor 노드로 가는 간선의 가중치만 추가해준다면 11번 노드는 follower 에 추가될 수 없음.
그래서 일단 같은 것도 추가해둠. (맞는지는 잘 모르겠음)

2. 위 결과에서 숫자들만 쭉 나열되어 있는 부분은 candidate edge 마다 delta_e 만큼 edge 보강을 해주었을 때 따라오는 follower 수를 적어놓은 것임.
예제에서는 다른 부분이 2개 있는데 sigma_plus 구현에 문제가 있는 것 같음.

저 문제를 확인해보기 위해서는 64, 90~92 디버깅 줄을 이용하면 됨.


